/*   =====================================================================

Copyright (c) 2017 by Omnesys Technologies, Inc.  All rights reserved.

Warning :
This Software Product is protected by copyright law and international
treaties.  Unauthorized use, reproduction or distribution of this
Software Product (including its documentation), or any portion of it,
may result in severe civil and criminal penalties, and will be
prosecuted to the maximum extent possible under the law.

Omnesys Technologies, Inc. will compensate individuals providing
admissible evidence of any unauthorized use, reproduction, distribution
or redistribution of this Software Product by any person, company or
organization.

This Software Product is licensed strictly in accordance with a separate
Software System License Agreement, granted by Omnesys Technologies, Inc., which
contains restrictions on use, reverse engineering, disclosure, confidentiality
and other matters.

=====================================================================   */
/*   =====================================================================
Compile/link commands for linux and darwin using R | API+.  These should
work if your pwd is the ./samples directory.  You may need to change the
name of the RApi library if you are using one of the library variants,
like R | API or R | Diamond API.

64-bit linux (2.6.32 kernel) :

g++ -O3 -DLINUX -D_REENTRANT -Wall -Wno-sign-compare -Wno-write-strings -Wpointer-arith -Winline -Wno-deprecated -fno-strict-aliasing -I../include -o SampleMD ../samples/SampleMD.cpp -L../linux-gnu-2.6.32-x86_64/lib -lRApiPlus-optimize -lOmneStreamEngine-optimize -lOmneChannel-optimize -lOmneEngine-optimize -l_api-optimize -l_apipoll-stubs-optimize -l_kit-optimize -lssl -lcrypto -L/usr/lib64 -lz -L/usr/kerberos/lib -lkrb5 -lk5crypto -lcom_err -lresolv -lm -lpthread -lrt

64-bit darwin :

g++ -O3 -DMacOS -D_REENTRANT -Wall -Wno-sign-compare -fno-strict-aliasing -Wpointer-arith -Winline -Wno-deprecated -Wno-write-strings -I../include -o ./SampleMD ../samples/SampleMD.cpp -L../darwin-10/lib -lRApiPlus-optimize -lOmneStreamEngine-optimize -lOmneChannel-optimize -lOmneEngine-optimize -l_api-optimize -l_apipoll-stubs-optimize -l_kit-optimize -lssl -lcrypto -L/usr/lib -lz -L/usr/lib -lkrb5 -lresolv -lm -lpthread

=====================================================================   */

#include "C:\Users\User\Documents\9.9.0.0\include\RApiPlus.h"

#include <iostream>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include "C:\Users\User\Documents\Visual Studio 2017\Projects\socketserver\stdafx.h"
#include "C:\Users\User\Documents\SocketServer\SocketApp.h"


#define GOOD 0
#define BAD  1

using namespace std;
using namespace RApi;

/*   =====================================================================   */

DWORD u32_Count = 8;
DWORD u32_Error;
int ph_Client[15];
DWORD u32_CountOld = 2;
int ps32_ClientIP[15];
int ps32_ClientCount[1];
bool g_bMdLoginComplete = false, serveropen = false;
double Bid = 0, Ask = 0;
char   BidBuffer[10];
char   AskBuffer[10];
int tuma = 0;
BOOL live = false;

int main(int      argc,
	char * * argv,
	char * * envp);

/*   =====================================================================   */
/*                          class declarations                               */
/*   =====================================================================   */

CSocketDemoDlg::~CSocketDemoDlg()
{
	DeleteCriticalSection(&mk_Critical);
}

BOOL CSocketDemoDlg::OnInitDialog()
{
	ms_Send = _T("Initializing Socket....");
	ms32_Port = 2000;

	mb_DlgClosed = FALSE;
	InitializeCriticalSection(&mk_Critical);

	// Get all local IP addresses for each network adapter
	DWORD u32_Err = mi_Socket.GetLocalIPs(&mi_LocalIPs);
	if (u32_Err)
		Print(_T("Error retrieving Local IP: %s"), GetErrMsg(u32_Err));

	CString s_Text;
#if _UNICODE
	s_Text = _T("Compiled as UNICODE,");
#else
	s_Text = _T("Compiled as MBCS,");
#endif

#if _DEBUG
	s_Text += _T(" DEBUG,");
#else
	s_Text += _T(" RELEASE,");
#endif

#if PROCESS_EVENTS_IN_GUI_THREAD
	s_Text += _T(" SingleThreaded,");
#else
	s_Text += _T(" MultiThreaded,");
#endif

	s_Text += _T(" Local IP = ");


	for (DWORD i = 0; i<mi_LocalIPs.GetCount(); i++)
	{
		CString s_IP = FormatIP(mi_LocalIPs.GetValueByIndex(i));

		if (i>0) s_Text += _T(" + ");
		s_Text += s_IP;
	}

	me_DemoMode = E_NORMAL;

	Print(s_Text);
	printf(s_Text);

	return TRUE;
}

BOOL CSocketDemoDlg::OnBtnListen()
{
	if (mi_Socket.GetSocketCount())
	{
		Print(_T("Socket already in use!"));
		printf("\nSocket already in use!\n");
		return FALSE;
	}

	DWORD u32_BindIP = 0;
	int s32_Sel = mi_LocalIPs.GetCount();
	if (s32_Sel > 0)
		u32_BindIP = mi_LocalIPs.GetValueByIndex(s32_Sel - 1);

	CString s_BindIP;

	DWORD u32_EventTimeout = (PROCESS_EVENTS_IN_GUI_THREAD) ? 50 : INFINITE;

	DWORD u32_Error = mi_Socket.Listen(u32_BindIP, ms32_Port, u32_EventTimeout, MAX_SERVER_IDLE_TIME);

	if (u32_Error)
	{
		Print(_T("Listen Error %s"), GetErrMsg(u32_Error));
		printf("\nListen Error %s\n", GetErrMsg(u32_Error));
		CloseSockets();
		return FALSE;
	}
	else
	{
		Print(_T("Listening (%s) on Port %d.... (waiting for FD_ACCEPT)."), s_BindIP, ms32_Port);
		printf("\nListening (%s) on Port %d.... (waiting for FD_ACCEPT).\n", s_BindIP, ms32_Port);
		if (MAX_SERVER_IDLE_TIME > 0)
		{
			Print(_T("Maximum idle time per client: %d seconds"), MAX_SERVER_IDLE_TIME);
			printf("Maximum idle time per client: %d seconds", MAX_SERVER_IDLE_TIME);
		}
	}

	// runs until an error occurred or all sockets have closed
#if PROCESS_EVENTS_IN_GUI_THREAD
	ProcessEvents();
#else
	DWORD u32_ID;
	mh_Thread = CreateThread(0, 0, ProcessEventThread, this, 0, &u32_ID);
#endif
	return TRUE;
}

// static
ULONG WINAPI CSocketDemoDlg::ProcessEventThread(void* p_Param)
{
	CSocketDemoDlg* p_This = (CSocketDemoDlg*)p_Param;
	p_This->ProcessEvents();
	CloseHandle(p_This->mh_Thread);
	return 0;
}

// Process all events which occur on one of the open sockets
void CSocketDemoDlg::ProcessEvents()
{
	BOOL b_Server = (mi_Socket.GetState() & TCP::cSocket::E_Server);

	while (TRUE) // Loop runs until the main window was closed or a severe error occurred
	{
#if PROCESS_EVENTS_IN_GUI_THREAD
		PumpMessages();
#endif

		TCP::cSocket::cMemory* pi_RecvMem;
		SOCKET  h_Socket;
		DWORD u32_Event, u32_IP, u32_Read, u32_Sent;
		DWORD u32_Err = mi_Socket.ProcessEvents(&u32_Event, &u32_IP, &h_Socket, &pi_RecvMem, &u32_Read, &u32_Sent);

		// Main Dialog was closed -> !Immediately! stop all output and printing into GUI.
		// Otherwise the application will not shut down correctly and the EXE keeps running. (only visible in Task Manager)
		// There may appear a lot of other strange things when the Events thread still runs while the GUI thread already finished!
		if (mb_DlgClosed)
			return;  // return NOT break!

		if (u32_Err == ERROR_TIMEOUT) // 50 ms interval has elapsed
			continue;

		CString s_Msg, s_Events;
		if (u32_Event) // ATTENTION: u32_Event may be == 0 -> do nothing.
		{
			if (b_Server) s_Events.Format(_T("Client %X (%s) --> "), h_Socket, FormatIP(u32_IP));
			else          s_Events.Format(_T("Server (%s) --> "), FormatIP(u32_IP));

			char s8_Events[200];
			mi_Socket.FormatEvents(u32_Event, s8_Events);
			s_Events += s8_Events;

			if (u32_Event & FD_READ)  s_Msg.Format(_T(" %d Bytes received."), u32_Read);
			if (u32_Event & FD_WRITE) s_Msg.Format(_T(" %d Bytes sent"), u32_Sent);

			Print(s_Events + s_Msg);

			if (u32_Event & FD_READ && pi_RecvMem) // pi_RecvMem may be NULL if an error occurred!!
			{
				switch (me_DemoMode)
				{
				case E_NORMAL:   ProcessReceivedDataNormal(pi_RecvMem); break;
				case E_PREFIXED: ProcessReceivedDataPrefix(pi_RecvMem); break;
				case E_TELNET:   ProcessReceivedDataTelnet(pi_RecvMem); break;
				}
			}
		}


		if (u32_Err)
		{
			// mi_Socket.Close() has been called -> don't print this error message
			if (u32_Err == WSAENOTCONN)
				break;

			// Print all the other error messages
			Print(_T("ProcessEvent Error %s"), GetErrMsg(u32_Err));

			// An error normally means that the socket has a problem -> abort the loop.
			// A few errors should not abort the processing:
			if (u32_Err != WSAECONNABORTED && // e.g. after the other side was killed in TaskManager 
				u32_Err != WSAECONNRESET   && // Connection reset by peer.
				u32_Err != WSAECONNREFUSED && // FD_ACCEPT with already 62 clients connected
				u32_Err != WSAESHUTDOWN)      // Sending data to a socket just in the short timespan 
				break;                        //   between shutdown() and closesocket()
		}
	}; // end loop

	CloseSockets();


	if (b_Server) Print(_T("Stop Listening.\r\n"));
	else          Print(_T("Connection abandoned.\r\n"));
}

// ##################################################################################################
//                                  PROCESS RECEIVED DATA
// ##################################################################################################

// Mode NORMAL:
// This simple "data processor" prints the data blocks immediately and unchanged as they arrive from the network
void CSocketDemoDlg::ProcessReceivedDataNormal(TCP::cSocket::cMemory* pi_RecvMem)
{
	char*  s8_Buf = pi_RecvMem->GetBuffer();
	DWORD u32_Len = pi_RecvMem->GetLength();

	CString s_String = CopyToString(s8_Buf, u32_Len);
	Print(_T("Received: '%s'"), s_String);

	// Delete all received data from the receive memory
	pi_RecvMem->DeleteLeft(u32_Len);
}

// Mode PREFIX:
// Each datablock comes prefixed with a DWORD which contains the total length of the datablock.
// So it is easy to determine if a block has been received completely.
// The data is accumulated in pi_RecvMem which works like a FIFO memory.
// This is the recommended principle for transmitting binary data.
// To test this mode set SEND_LARGE_DATA to 100 and set READ_BUFFER_SIZE to 30
void CSocketDemoDlg::ProcessReceivedDataPrefix(TCP::cSocket::cMemory* pi_RecvMem)
{
	while (TRUE) // There may arrive multiple datablocks at once -> loop until FIFO is empty
	{
		char*  s8_Buf = pi_RecvMem->GetBuffer();
		DWORD u32_Len = pi_RecvMem->GetLength();
		if (u32_Len < 4)
			return; // There must always be at least 1 Dword

		DWORD u32_Blocksize = ((DWORD*)s8_Buf)[0];
		if (u32_Blocksize > u32_Len)
		{
			Print(_T("%d Bytes in RecvMemory (Blocksize= %d Byte) Waiting for more data..."), u32_Len, u32_Blocksize);
			return; // The block is not yet complete -> accumulate more data in pi_RecvMem
		}

		CString s_String = CopyToString(s8_Buf + 4, u32_Blocksize - 4);
		Print(_T("Received entire datablock (%d Bytes): '%s'"), u32_Blocksize, s_String);

		// Only delete the data that has been processed and leave the rest.
		// ATTENTION: DeleteLeft(u32_Len) would result in data loss!!
		pi_RecvMem->DeleteLeft(u32_Blocksize);
	}
}

// Mode TELNET:
// This function demonstrates how single characters received from a Telnet client
// are accumulated in pi_RecvMem, which works like a FIFO memory, until a line feed is found.
// When a line is complete it is printed to the screen and deleted from pi_RecvMem.
void CSocketDemoDlg::ProcessReceivedDataTelnet(TCP::cSocket::cMemory* pi_RecvMem)
{
#if _UNICODE
	Print(_T("Telnet does not use Unicode. Please compile the Telnet demo as MBCS!"));
	return;
#endif;

	// If you send "Hello\nWorld\n" from SocketDemo instead of using a real Telnet client this requires a loop
	while (TRUE)
	{
		char*  s8_Buf = pi_RecvMem->GetBuffer();
		DWORD u32_Len = pi_RecvMem->GetLength();

		CString s_String = CopyToString(s8_Buf, u32_Len);
		int s32_Pos = s_String.Find('\n');
		if (s32_Pos < 0)
		{
			Print(_T("%d Bytes in RecvMemory. Waiting for linefeed..."), u32_Len);
			return; // The line is not yet complete -> accumulate more characters
		}

		s_String = s_String.Left(s32_Pos);
		s_String.Replace(_T("\r"), _T(""));

		// Print all characters up to the "\n"
		Print(_T("Received entire line: '%s'"), s_String);

		// Delete all characters including the "\n" itself from the receive memory
		// but leave all characters in RecvMem which follow the "\n"
		pi_RecvMem->DeleteLeft(s32_Pos + 1);
	};
}

// ##################################################################################################
//                                            END
// ##################################################################################################

// Close all open sockets
int CSocketDemoDlg::OnBtnClose()
{
	DWORD cnt;
	cnt = mi_Socket.GetSocketCount();
	return cnt;
}

// Close all open sockets (if any)
void CSocketDemoDlg::CloseSockets()
{
	if (mi_Socket.GetSocketCount())
	{
		mi_Socket.Close();
		Print(_T("Socket(s) closed."));

	}
}

// Send a text string to one or multiple destinations
void CSocketDemoDlg::OnBtnSend(double &Bid, double &Ask)
{
	DWORD tym = GetTickCount();

	if (!mi_Socket.GetSocketCount())
	{
		Print(_T("Not connected!"));
		printf("\nNot connected!\n");
		return;
	}

#if SEND_LARGE_DATA > 0
	// SEND_LARGE_DATA = 100000 -> send a 100 Kilobyte string "AAAAAAAA...", each time with another character
	static TCHAR t_Chr = 'A';
	CString s_SendData(t_Chr++, SEND_LARGE_DATA / sizeof(TCHAR));
	if (t_Chr > 'Z') t_Chr = 'A';
#else
	// send the string that the user has entered
	
	if (Bid == 0 && Ask != 0)
	{
		int j = sprintf(AskBuffer, "%.3f", Ask);
	}
	elseif(Ask == 0 && Bid != 0)
	{
		j = sprintf(BidBuffer, "%.3f", Bid);
	}
	else
	{
		j = sprintf(BidBuffer, "%.3f", Bid);
		
	}

	printf("BidBuffer is :\"%s\"\n", BidBuffer);
	printf("AskBuffer is :\"%s\"\n", AskBuffer);
	
	ms_Send = j;
	CString s_SendData = ms_Send;
#endif

	if (!s_SendData.GetLength())
	{
		Print(_T("Error: You must enter a text!"));
		printf("\nError: You must enter a text!\n");
		return;
	}

	printf("\nText to be sent is : %s\n", s_SendData);

	DWORD nos = mi_Socket.GetAllConnectedSockets(&mi_SocketList);
	printf("\nGetAllConnectedSockets is : %d\n", nos);
	// Get the socket handle which is stored

	for (DWORD i = 0; i < mi_SocketList.GetCount(); i++)
	{
		SOCKET h_Socket = mi_SocketList.GetKeyByIndex(i);
		if (!SendTo(h_Socket, s_SendData))
		{
			break;
			printf("\nFailed to send to socket\n");
		}
		else
			printf("\nSuccessfully sent\n");
	}

	printf("\nValue of mi_SocketList is : %d\n", mi_SocketList.GetCount());
	tym = GetTickCount() - tym;
	Print(_T("Speed is : %d milliseconds"), tym);
	printf("\nSpeed is : %d milliseconds\n", tym);
}

// Sends data to the given socket
// A "\r\n" in the input string is replaced with a linebreak
// returns FALSE when the sockets have been closed due to a severe error
BOOL CSocketDemoDlg::SendTo(SOCKET h_Socket, CString s_SendData)
{
	CString s_Text = s_SendData;
	if (s_Text.GetLength() > 50)
		s_Text = s_Text.Left(50) + "...<cut>";

	s_SendData.Replace(_T("\\n"), _T("\n"));
	s_SendData.Replace(_T("\\r"), _T("\r"));

	// If Unicode: 1 character = 2 Bytes!
	DWORD u32_Len = s_SendData.GetLength() * sizeof(TCHAR);

	Print(_T("Sending %d Bytes to %s: '%s'"), u32_Len, FormatDisplayName(h_Socket), s_Text);

	// Insert a DWORD at the begin which contains the total length of the sent data
	if (me_DemoMode == E_PREFIXED)
	{
		// We need always 4 BYTES (=2 characters if Unicode, =4 characters if MBCS)
		CString s_Prefix('x', 4 / sizeof(TCHAR));
		s_SendData.Insert(0, s_Prefix); // insert "xx" or "xxxx"
	}

	char* s8_Data = (char*)(const TCHAR*)s_SendData; // get buffer AFTER Insert() !!!

	if (me_DemoMode == E_PREFIXED)
	{
		u32_Len += 4;                   // set to total length of datablock
		((DWORD*)s8_Data)[0] = u32_Len; // replace "xxxx" with the length of the send data block
	}

	DWORD u32_Err = mi_Socket.SendTo(h_Socket, s8_Data, u32_Len);

	switch (u32_Err)
	{
	case 0:
		return TRUE;

	case WSAEWOULDBLOCK:
		Print(_T("WSAEWOULDBLOCK -> The data will be send after the next FD_WRITE event."));
		return TRUE;

	case WSA_IO_PENDING:
		Print(_T("WSA_IO_PENDING -> Error: A previous Send operation is still pending. This data will not be sent."));
		return TRUE;

	default:
		Print(_T("%s"), _T(" -> Error ") + GetErrMsg(u32_Err));
		// Severe error -> abort event loop
		CloseSockets();
		return FALSE;
	};
}


// When the main dialog is closed: set the mb_DlgClosed flag to abort the ProcessEvents() Thread!
void CSocketDemoDlg::OnClose()
{
	mb_DlgClosed = TRUE;
	mi_Socket.Close();
}

/*   =====================================================================   */
/*                          class declarations                               */
/*   =====================================================================   */

class MyAdmCallbacks : public AdmCallbacks
{
public:
	MyAdmCallbacks() {};
	~MyAdmCallbacks() {};

	/*   ----------------------------------------------------------------   */

	virtual int Alert(AlertInfo * pInfo,
		void *      pContext,
		int *       aiCode);
};

/*   =====================================================================   */

class MyCallbacks : public RCallbacks
{
public:
	MyCallbacks() {};
	~MyCallbacks() {};

	/*   ----------------------------------------------------------------   */

	virtual int Alert(AlertInfo * pInfo,
		void *      pContext,
		int *       aiCode);

	/*   ----------------------------------------------------------------   */

	virtual int AskQuote(AskInfo * pInfo,
		void *    pContext,
		int *     aiCode);

	virtual int BestAskQuote(AskInfo * pInfo,
		void *    pContext,
		int *     aiCode);

	virtual int BestBidAskQuote(BidInfo * pBid,
		AskInfo * pAsk,
		void *    pContext,
		int *     aiCode);

	virtual int BestBidQuote(BidInfo * pInfo,
		void *    pContext,
		int *     aiCode);

	virtual int BidQuote(BidInfo * pInfo,
		void *    pContext,
		int *     aiCode);

	virtual int BinaryContractList(BinaryContractListInfo * pInfo,
		void *                   pContext,
		int *                    aiCode);

	virtual int ClosePrice(ClosePriceInfo * pInfo,
		void *           pContext,
		int *            aiCode);

	virtual int ClosingIndicator(ClosingIndicatorInfo * pInfo,
		void *                 pContext,
		int *                  aiCode);

	virtual int EndQuote(EndQuoteInfo * pInfo,
		void *         pContext,
		int *          aiCode);

	virtual int EquityOptionStrategyList(EquityOptionStrategyListInfo * pInfo,
		void *                         pContext,
		int *                          aiCode);

	virtual int HighPrice(HighPriceInfo * pInfo,
		void *          pContext,
		int *           aiCode);

	virtual int InstrumentByUnderlying(InstrumentByUnderlyingInfo * pInfo,
		void *                       pContext,
		int *                        aiCode);

	virtual int InstrumentSearch(InstrumentSearchInfo * pInfo,
		void *                 pContext,
		int *                  aiCode);

	virtual int LimitOrderBook(LimitOrderBookInfo * pInfo,
		void *               pContext,
		int *                aiCode);

	virtual int LowPrice(LowPriceInfo * pInfo,
		void *         pContext,
		int *          aiCode);

	virtual int MarketMode(MarketModeInfo * pInfo,
		void *           pContext,
		int *            aiCode);

	virtual int OpenInterest(OpenInterestInfo * pInfo,
		void *             pContext,
		int *              aiCode);

	virtual int OpenPrice(OpenPriceInfo * pInfo,
		void *          pContext,
		int *           aiCode);

	virtual int OpeningIndicator(OpeningIndicatorInfo * pInfo,
		void *                 pContext,
		int *                  aiCode);

	virtual int OptionList(OptionListInfo * pInfo,
		void *           pContext,
		int *            aiCode);

	virtual int RefData(RefDataInfo * pInfo,
		void *        pContext,
		int *         aiCode);

	virtual int SettlementPrice(SettlementPriceInfo * pInfo,
		void *                pContext,
		int *                 aiCode);

	virtual int Strategy(StrategyInfo * pInfo,
		void *         pContext,
		int *          aiCode);

	virtual int StrategyList(StrategyListInfo * pInfo,
		void *             pContext,
		int *              aiCode);

	virtual int TradeCondition(TradeInfo * pInfo,
		void *      pContext,
		int *       aiCode);

	virtual int TradePrint(TradeInfo * pInfo,
		void *      pContext,
		int *       aiCode);

	virtual int TradeReplay(TradeReplayInfo * pInfo,
		void *            pContext,
		int *             aiCode);

	virtual int TradeRoute(TradeRouteInfo * pInfo,
		void *           pContext,
		int *            aiCode);

	virtual int TradeRouteList(TradeRouteListInfo * pInfo,
		void *               pContext,
		int *                aiCode);

	virtual int TradeVolume(TradeVolumeInfo * pInfo,
		void *            pContext,
		int *             aiCode);

	/*   ----------------------------------------------------------------   */

	virtual int Bar(BarInfo * pInfo,
		void *    pContext,
		int *     aiCode);

	virtual int BarReplay(BarReplayInfo * pInfo,
		void *          pContext,
		int *           aiCode);

	/*   ----------------------------------------------------------------   */

	virtual int AccountList(AccountListInfo * pInfo,
		void *            pContext,
		int *             aiCode);

	virtual int PasswordChange(PasswordChangeInfo * pInfo,
		void *               pContext,
		int *                aiCode);

	/*   ----------------------------------------------------------------   */

	virtual int ExchangeList(ExchangeListInfo * pInfo,
		void *             pContext,
		int *              aiCode);

	virtual int ExecutionReplay(ExecutionReplayInfo * pInfo,
		void *                pContext,
		int *                 aiCode);

	virtual int LineUpdate(LineInfo * pInfo,
		void *     pContext,
		int *      aiCode);

	virtual int OpenOrderReplay(OrderReplayInfo * pInfo,
		void *            pContext,
		int *             aiCode);

	virtual int OrderReplay(OrderReplayInfo * pInfo,
		void *            pContext,
		int *             aiCode);

	virtual int PnlReplay(PnlReplayInfo * pInfo,
		void *          pContext,
		int *           aiCode);

	virtual int PnlUpdate(PnlInfo * pInfo,
		void *    pContext,
		int *     aiCode);

	virtual int PriceIncrUpdate(PriceIncrInfo * pInfo,
		void *          pContext,
		int *           aiCode);

	virtual int ProductRmsList(ProductRmsListInfo * pInfo,
		void *               pContext,
		int *                aiCode);

	virtual int SingleOrderReplay(SingleOrderReplayInfo * pInfo,
		void *                  pContext,
		int *                   aiCode);

	/*   ----------------------------------------------------------------   */

	virtual int BustReport(OrderBustReport * pReport,
		void *            pContext,
		int *             aiCode);

	virtual int CancelReport(OrderCancelReport * pReport,
		void *              pContext,
		int *               aiCode);

	virtual int FailureReport(OrderFailureReport * pReport,
		void *               pContext,
		int *                aiCode);

	virtual int FillReport(OrderFillReport * pReport,
		void *            pContext,
		int *             aiCode);

	virtual int ModifyReport(OrderModifyReport * pReport,
		void *              pContext,
		int *               aiCode);

	virtual int NotCancelledReport(OrderNotCancelledReport * pReport,
		void *                    pContext,
		int *                     aiCode);

	virtual int NotModifiedReport(OrderNotModifiedReport * pReport,
		void *                   pContext,
		int *                    aiCode);

	virtual int RejectReport(OrderRejectReport * pReport,
		void *              pContext,
		int *               aiCode);

	virtual int StatusReport(OrderStatusReport * pReport,
		void *              pContext,
		int *               aiCode);

	virtual int TradeCorrectReport(OrderTradeCorrectReport * pReport,
		void *                    pContext,
		int *                     aiCode);

	virtual int TriggerPulledReport(OrderTriggerPulledReport * pReport,
		void *                     pContext,
		int *                      aiCode);

	virtual int TriggerReport(OrderTriggerReport * pReport,
		void *              pContext,
		int *               aiCode);

	virtual int OtherReport(OrderReport * pReport,
		void *        pContext,
		int *         aiCode);

	/*   ----------------------------------------------------------------   */

	virtual int SodUpdate(SodReport * pReport,
		void *      pContext,
		int *       aiCode);

	/*   ----------------------------------------------------------------   */

	virtual int Quote(QuoteReport * pReport,
		void *        pContext,
		int *         aiCode);

	/*   ----------------------------------------------------------------   */

	virtual void send(double &Bid, double &Ask);

	/*   ----------------------------------------------------------------   */

private:
};

/*   =====================================================================   */
/*                          class definitions                                */
/*   =====================================================================   */

void MyCallbacks::send(double &Bid, double &Ask)
{
	CSocketDemoDlg acc;
	if (acc.OnBtnClose()>0)
	{
		acc.OnBtnSend(Bid, Ask);
		printf("\nSent to Client...\n");
	}
	else
		printf("\nFailed...\n");
}


/*   =====================================================================   */

int MyAdmCallbacks::Alert(AlertInfo * pInfo,
	void *      pContext,
	int *       aiCode)
{
	int iIgnored;

	/*   ----------------------------------------------------------------   */

	cout << endl << endl;
	if (!pInfo->dump(&iIgnored))
	{
		cout << "error in pInfo -> dump : " << iIgnored << endl;
	}

	/*   ----------------------------------------------------------------   */

	*aiCode = API_OK;
	return (OK);
}

/*   =====================================================================   */

int MyCallbacks::AccountList(AccountListInfo * pInfo,
	void *            pContext,
	int *             aiCode)
{
	*aiCode = API_OK;
	return (OK);
}

/*   =====================================================================   */

int MyCallbacks::PasswordChange(PasswordChangeInfo * pInfo,
	void *               pContext,
	int *                aiCode)
{
	*aiCode = API_OK;
	return (OK);
}

/*   =====================================================================   */

int MyCallbacks::Alert(AlertInfo * pInfo,
	void *      pContext,
	int *       aiCode)
{
	int iIgnored;

	/*   ----------------------------------------------------------------   */

	cout << endl << endl;
	if (!pInfo->dump(&iIgnored))
	{
		cout << "error in pInfo -> dump : " << iIgnored << endl;
	}

	/*   ----------------------------------------------------------------   */
	/*   Signal when the login to the market data system (ticker plant)     */
	/*   is complete.                                                       */

	if (pInfo->iAlertType == ALERT_LOGIN_COMPLETE &&
		pInfo->iConnectionId == MARKET_DATA_CONNECTION_ID)
	{
		g_bMdLoginComplete = true;
	}

	/*   ----------------------------------------------------------------   */

	*aiCode = API_OK;
	return (OK);
}

/*   =====================================================================   */

int MyCallbacks::ExchangeList(ExchangeListInfo * pInfo,
	void *             pContext,
	int *              aiCode)
{
	*aiCode = API_OK;
	return (OK);
}

/*   =====================================================================   */

int MyCallbacks::ExecutionReplay(ExecutionReplayInfo * pInfo,
	void *                pContext,
	int *                 aiCode)
{
	*aiCode = API_OK;
	return(OK);
}


/*   =====================================================================   */

int MyCallbacks::LineUpdate(LineInfo * pInfo,
	void *     pContext,
	int *      aiCode)
{
	*aiCode = API_OK;
	return(OK);
}

/*   =====================================================================   */

int MyCallbacks::OpenOrderReplay(OrderReplayInfo * pInfo,
	void *            pContext,
	int *             aiCode)
{
	*aiCode = API_OK;
	return(OK);
}


/*   =====================================================================   */

int MyCallbacks::OrderReplay(OrderReplayInfo * pInfo,
	void *            pContext,
	int *             aiCode)
{
	*aiCode = API_OK;
	return(OK);
}


/*   =====================================================================   */

int MyCallbacks::PnlReplay(PnlReplayInfo * pInfo,
	void *          pContext,
	int *           aiCode)
{
	*aiCode = API_OK;
	return(OK);
}

/*   =====================================================================   */

int MyCallbacks::PnlUpdate(PnlInfo * pInfo,
	void *    pContext,
	int *     aiCode)
{
	*aiCode = API_OK;
	return(OK);
}

/*   =====================================================================   */

int MyCallbacks::PriceIncrUpdate(PriceIncrInfo * pInfo,
	void *          pContext,
	int *           aiCode)
{
	int iIgnored;

	/*   ----------------------------------------------------------------   */

	cout << endl << endl;
	if (!pInfo->dump(&iIgnored))
	{
		cout << "error in pInfo -> dump : " << iIgnored << endl;
	}

	/*   ----------------------------------------------------------------   */

	*aiCode = API_OK;
	return(OK);
}

/*   =====================================================================   */

int MyCallbacks::ProductRmsList(ProductRmsListInfo * pInfo,
	void *               pContext,
	int *                aiCode)
{
	*aiCode = API_OK;
	return(OK);
}

/*   =====================================================================   */

int MyCallbacks::SingleOrderReplay(SingleOrderReplayInfo * pInfo,
	void *                  pContext,
	int *                   aiCode)
{
	*aiCode = API_OK;
	return(OK);
}

/*   =====================================================================   */

int MyCallbacks::BustReport(OrderBustReport * pReport,
	void *            pContext,
	int *             aiCode)
{
	*aiCode = API_OK;
	return(OK);
}

/*   =====================================================================   */

int MyCallbacks::CancelReport(OrderCancelReport * pReport,
	void *              pContext,
	int *               aiCode)
{
	*aiCode = API_OK;
	return(OK);
}

/*   =====================================================================   */

int MyCallbacks::FailureReport(OrderFailureReport * pReport,
	void *               pContext,
	int *                aiCode)
{
	*aiCode = API_OK;
	return(OK);
}

/*   =====================================================================   */

int MyCallbacks::FillReport(OrderFillReport * pReport,
	void *            pContext,
	int *             aiCode)
{
	*aiCode = API_OK;
	return(OK);
}

/*   =====================================================================   */

int MyCallbacks::ModifyReport(OrderModifyReport * pReport,
	void *              pContext,
	int *               aiCode)
{
	*aiCode = API_OK;
	return(OK);
}

/*   =====================================================================   */

int MyCallbacks::NotCancelledReport(OrderNotCancelledReport * pReport,
	void *                    pContext,
	int *                     aiCode)
{
	*aiCode = API_OK;
	return(OK);
}

/*   =====================================================================   */

int MyCallbacks::NotModifiedReport(OrderNotModifiedReport * pReport,
	void *                   pContext,
	int *                    aiCode)
{
	*aiCode = API_OK;
	return(OK);
}

/*   =====================================================================   */

int MyCallbacks::RejectReport(OrderRejectReport * pReport,
	void *              pContext,
	int *               aiCode)
{
	*aiCode = API_OK;
	return(OK);
}

/*   =====================================================================   */

int MyCallbacks::StatusReport(OrderStatusReport * pReport,
	void *              pContext,
	int *               aiCode)
{
	*aiCode = API_OK;
	return(OK);
}

/*   =====================================================================   */

int MyCallbacks::TradeCorrectReport(OrderTradeCorrectReport * pReport,
	void *                    pContext,
	int *                     aiCode)
{
	*aiCode = API_OK;
	return(OK);
}

/*   =====================================================================   */

int MyCallbacks::TriggerPulledReport(OrderTriggerPulledReport * pReport,
	void *                     pContext,
	int *                      aiCode)
{
	*aiCode = API_OK;
	return(OK);
}

/*   =====================================================================   */

int MyCallbacks::TriggerReport(OrderTriggerReport * pReport,
	void *               pContext,
	int *                aiCode)
{
	*aiCode = API_OK;
	return(OK);
}

/*   =====================================================================   */

int MyCallbacks::OtherReport(OrderReport * pReport,
	void *        pContext,
	int *         aiCode)
{
	*aiCode = API_OK;
	return(OK);
}

/*   =====================================================================   */

int MyCallbacks::SodUpdate(SodReport * pReport,
	void *      pContext,
	int *       aiCode)
{
	*aiCode = API_OK;
	return(OK);
}

/*   =====================================================================   */

int MyCallbacks::Quote(QuoteReport * pReport,
	void *        pContext,
	int *         aiCode)
{
	*aiCode = API_OK;
	return(OK);
}

/*   =====================================================================   */

int MyCallbacks::AskQuote(AskInfo * pInfo,
	void *    pContext,
	int *     aiCode)
{
	int iIgnored;

	/*   ----------------------------------------------------------------   */

	cout << endl << endl;
	if (!pInfo->dump(&iIgnored))
	{
		cout << "error in pInfo -> dump : " << iIgnored << endl;
	}

	/*   ----------------------------------------------------------------   */

	*aiCode = API_OK;
	return (OK);
}

/*   =====================================================================   */

int MyCallbacks::BestAskQuote(AskInfo * pInfo,
	void *    pContext,
	int *     aiCode)
{
	int iIgnored;

	/*   ----------------------------------------------------------------   */

	cout << endl << endl << "Best";
	if (!pInfo->dump(&iIgnored))
	{
		cout << "error in pInfo -> dump : " << iIgnored << endl;
	}

	Ask = pInfo->dPrice;
	send(Bid, Ask);

	/*   ----------------------------------------------------------------   */

	*aiCode = API_OK;
	return (OK);
}

/*   =====================================================================   */

int MyCallbacks::BestBidAskQuote(BidInfo * pBid,
	AskInfo * pAsk,
	void *    pContext,
	int *     aiCode)
{
	int iIgnored;

	/*   ----------------------------------------------------------------   */

	cout << endl << endl << "Best Bid/Ask";
	if (!pBid->dump(&iIgnored))
	{
		cout << "error in pBid -> dump : " << iIgnored << endl;
	}

	if (!pAsk->dump(&iIgnored))
	{
		cout << "error in pAsk -> dump : " << iIgnored << endl;
	}

	Bid = pBid->dPrice;
	Ask = pAsk->dPrice;
	send(Bid, Ask);

	/*   ----------------------------------------------------------------   */

	*aiCode = API_OK;
	return (OK);
}

/*   =====================================================================   */

int MyCallbacks::BestBidQuote(BidInfo * pInfo,
	void *    pContext,
	int *     aiCode)
{
	int iIgnored;

	/*   ----------------------------------------------------------------   */

	cout << endl << endl << "Best";
	if (!pInfo->dump(&iIgnored))
	{
		cout << "error in pInfo -> dump : " << iIgnored << endl;
	}

	Bid = pInfo->dPrice;
	send(Bid, Ask);

	/*   ----------------------------------------------------------------   */

	*aiCode = API_OK;
	return (OK);
}

/*   =====================================================================   */

int MyCallbacks::BidQuote(BidInfo * pInfo,
	void *    pContext,
	int *     aiCode)
{
	int iIgnored;

	/*   ----------------------------------------------------------------   */

	cout << endl << endl;
	if (!pInfo->dump(&iIgnored))
	{
		cout << "error in pInfo -> dump : " << iIgnored << endl;
	}

	/*   ----------------------------------------------------------------   */

	*aiCode = API_OK;
	return (OK);
}

/*   =====================================================================   */

int MyCallbacks::BinaryContractList(BinaryContractListInfo * pInfo,
	void *                   pContext,
	int *                    aiCode)
{
	*aiCode = API_OK;
	return (OK);
}

/*   =====================================================================   */

int MyCallbacks::ClosePrice(ClosePriceInfo * pInfo,
	void *           pContext,
	int *            aiCode)
{
	int iIgnored;

	/*   ----------------------------------------------------------------   */

	cout << endl << endl;
	if (!pInfo->dump(&iIgnored))
	{
		cout << "error in pInfo -> dump : " << iIgnored << endl;
	}

	/*   ----------------------------------------------------------------   */

	*aiCode = API_OK;
	return (OK);
}

/*   =====================================================================   */

int MyCallbacks::ClosingIndicator(ClosingIndicatorInfo * pInfo,
	void *                 pContext,
	int *                  aiCode)
{
	int iIgnored;

	/*   ----------------------------------------------------------------   */

	cout << endl << endl;
	if (!pInfo->dump(&iIgnored))
	{
		cout << "error in pInfo -> dump : " << iIgnored << endl;
	}

	/*   ----------------------------------------------------------------   */

	*aiCode = API_OK;
	return (OK);
}

/*   =====================================================================   */

int MyCallbacks::EndQuote(EndQuoteInfo * pInfo,
	void *         pContext,
	int *          aiCode)
{
	int iIgnored;

	/*   ----------------------------------------------------------------   */

	cout << endl << endl;
	if (!pInfo->dump(&iIgnored))
	{
		cout << "error in pInfo -> dump : " << iIgnored << endl;
	}

	/*   ----------------------------------------------------------------   */

	*aiCode = API_OK;
	return (OK);
}

/*   =====================================================================   */

int MyCallbacks::EquityOptionStrategyList(EquityOptionStrategyListInfo * pInfo,
	void *                         pContext,
	int *                          aiCode)
{
	*aiCode = API_OK;
	return (OK);
}

/*   =====================================================================   */

int MyCallbacks::HighPrice(HighPriceInfo * pInfo,
	void *          pContext,
	int *           aiCode)
{
	int iIgnored;

	/*   ----------------------------------------------------------------   */

	cout << endl << endl;
	if (!pInfo->dump(&iIgnored))
	{
		cout << "error in pInfo -> dump : " << iIgnored << endl;
	}

	/*   ----------------------------------------------------------------   */

	*aiCode = API_OK;
	return (OK);
}

/*   =====================================================================   */

int MyCallbacks::InstrumentByUnderlying(InstrumentByUnderlyingInfo * pInfo,
	void *                       pContext,
	int *                        aiCode)
{
	*aiCode = API_OK;
	return (OK);
}

/*   =====================================================================   */

int MyCallbacks::InstrumentSearch(InstrumentSearchInfo * pInfo,
	void *                 pContext,
	int *                  aiCode)
{
	*aiCode = API_OK;
	return (OK);
}

/*   =====================================================================   */
int MyCallbacks::LimitOrderBook(LimitOrderBookInfo * pInfo,
	void *               pContext,
	int *                aiCode)
{
	int iIgnored;

	/*   ----------------------------------------------------------------   */

	cout << endl << endl;
	if (!pInfo->dump(&iIgnored))
	{
		cout << "error in pInfo -> dump : " << iIgnored << endl;
	}

	/*   ----------------------------------------------------------------   */

	*aiCode = API_OK;
	return (OK);
}

/*   =====================================================================   */

int MyCallbacks::LowPrice(LowPriceInfo * pInfo,
	void *         pContext,
	int *          aiCode)
{
	int iIgnored;

	/*   ----------------------------------------------------------------   */

	cout << endl << endl;
	if (!pInfo->dump(&iIgnored))
	{
		cout << "error in pInfo -> dump : " << iIgnored << endl;
	}

	/*   ----------------------------------------------------------------   */

	*aiCode = API_OK;
	return (OK);
}

/*   =====================================================================   */

int MyCallbacks::MarketMode(MarketModeInfo * pInfo,
	void *           pContext,
	int *            aiCode)
{
	int iIgnored;

	/*   ----------------------------------------------------------------   */

	cout << endl << endl;
	if (!pInfo->dump(&iIgnored))
	{
		cout << "error in pInfo -> dump : " << iIgnored << endl;
	}

	/*   ----------------------------------------------------------------   */

	*aiCode = API_OK;
	return (OK);
}

/*   =====================================================================   */

int MyCallbacks::OpenInterest(OpenInterestInfo * pInfo,
	void *             pContext,
	int *              aiCode)
{
	int iIgnored;

	/*   ----------------------------------------------------------------   */

	cout << endl << endl;
	if (!pInfo->dump(&iIgnored))
	{
		cout << "error in pInfo -> dump : " << iIgnored << endl;
	}

	/*   ----------------------------------------------------------------   */

	*aiCode = API_OK;
	return (OK);
}

/*   =====================================================================   */

int MyCallbacks::OpenPrice(OpenPriceInfo * pInfo,
	void *          pContext,
	int *           aiCode)
{
	int iIgnored;

	/*   ----------------------------------------------------------------   */

	cout << endl << endl;
	if (!pInfo->dump(&iIgnored))
	{
		cout << "error in pInfo -> dump : " << iIgnored << endl;
	}

	/*   ----------------------------------------------------------------   */

	*aiCode = API_OK;
	return (OK);
}

/*   =====================================================================   */

int MyCallbacks::OpeningIndicator(OpeningIndicatorInfo * pInfo,
	void *                 pContext,
	int *                  aiCode)
{
	int iIgnored;

	/*   ----------------------------------------------------------------   */

	cout << endl << endl;
	if (!pInfo->dump(&iIgnored))
	{
		cout << "error in pInfo -> dump : " << iIgnored << endl;
	}

	/*   ----------------------------------------------------------------   */

	*aiCode = API_OK;
	return (OK);
}

/*   =====================================================================   */

int MyCallbacks::OptionList(OptionListInfo * pInfo,
	void *           pContext,
	int *            aiCode)
{
	*aiCode = API_OK;
	return (OK);
}

/*   =====================================================================   */

int MyCallbacks::RefData(RefDataInfo * pInfo,
	void *        pContext,
	int *         aiCode)
{
	*aiCode = API_OK;
	return (OK);
}

/*   =====================================================================   */

int MyCallbacks::SettlementPrice(SettlementPriceInfo * pInfo,
	void *                pContext,
	int *                 aiCode)
{
	int iIgnored;

	/*   ----------------------------------------------------------------   */

	cout << endl << endl;
	if (!pInfo->dump(&iIgnored))
	{
		cout << "error in pInfo -> dump : " << iIgnored << endl;
	}

	/*   ----------------------------------------------------------------   */

	*aiCode = API_OK;
	return (OK);
}

/*   =====================================================================   */

int MyCallbacks::Strategy(StrategyInfo * pInfo,
	void *         pContext,
	int *          aiCode)
{
	*aiCode = API_OK;
	return (OK);
}

/*   =====================================================================   */

int MyCallbacks::StrategyList(StrategyListInfo * pInfo,
	void *             pContext,
	int *              aiCode)
{
	*aiCode = API_OK;
	return (OK);
}

/*   =====================================================================   */

int MyCallbacks::TradeCondition(TradeInfo * pInfo,
	void *      pContext,
	int *       aiCode)
{
	int iIgnored;

	/*   ----------------------------------------------------------------   */

	cout << endl << endl;
	if (!pInfo->dump(&iIgnored))
	{
		cout << "error in pInfo -> dump : " << iIgnored << endl;
	}

	/*   ----------------------------------------------------------------   */

	*aiCode = API_OK;
	return (OK);
}

/*   =====================================================================   */

int MyCallbacks::TradePrint(TradeInfo * pInfo,
	void *      pContext,
	int *       aiCode)
{
	int iIgnored;

	/*   ----------------------------------------------------------------   */

	cout << endl << endl;
	if (!pInfo->dump(&iIgnored))
	{
		cout << "error in pInfo -> dump : " << iIgnored << endl;
	}

	/*   ----------------------------------------------------------------   */

	*aiCode = API_OK;
	return (OK);
}

/*   =====================================================================   */

int MyCallbacks::TradeReplay(TradeReplayInfo * pInfo,
	void *            pContext,
	int *             aiCode)
{
	*aiCode = API_OK;
	return (OK);
}

/*   =====================================================================   */

int MyCallbacks::TradeRoute(TradeRouteInfo * pInfo,
	void *           pContext,
	int *            aiCode)
{
	*aiCode = API_OK;
	return(OK);
}

/*   =====================================================================   */

int MyCallbacks::TradeRouteList(TradeRouteListInfo * pInfo,
	void *               pContext,
	int *                aiCode)
{
	*aiCode = API_OK;
	return(OK);
}

/*   =====================================================================   */

int MyCallbacks::TradeVolume(TradeVolumeInfo * pInfo,
	void *            pContext,
	int *             aiCode)
{
	int iIgnored;

	/*   ----------------------------------------------------------------   */

	cout << endl << endl;
	if (!pInfo->dump(&iIgnored))
	{
		cout << "error in pInfo -> dump : " << iIgnored << endl;
	}

	/*   ----------------------------------------------------------------   */

	*aiCode = API_OK;
	return (OK);
}

/*   =====================================================================   */

int MyCallbacks::Bar(BarInfo * pInfo,
	void *    pContext,
	int *     aiCode)
{
	*aiCode = API_OK;
	return (OK);
}

/*   =====================================================================   */

int MyCallbacks::BarReplay(BarReplayInfo * pInfo,
	void *          pContext,
	int *           aiCode)
{
	*aiCode = API_OK;
	return (OK);
}

/*   =====================================================================   */

int main(int      argc,
	char * * argv,
	char * * envp)
{
	char * USAGE = (char *)"SampleMD user password exchange ticker";

	REngine *        pEngine;
	MyAdmCallbacks * pAdmCallbacks;
	RCallbacks *     pCallbacks;
	REngineParams    oParams;
	LoginParams      oLoginParams;
	AskInfo *		 pInfo;
	tsNCharcb        sExchange;
	tsNCharcb        sTicker;
	char *           fake_envp[11];
	int              iFlags;
	int              iCode;
	void *			 context;
	CSocketDemoDlg 		map;

	/*   ----------------------------------------------------------------   */

	if (argc < 5)
	{
		cout << USAGE << endl;
		return (BAD);
	}

	/*   ----------------------------------------------------------------   */


	if (live == false)
	{
		bool printed = false;
		if (map.OnInitDialog())
		{
			printf("\nServer initialized...\n");
			if (map.OnBtnListen())
			{
				printf("\nListening...\n");
				live = true;
			}
		}
		else
			printf("\nServer failed to initialize...\n");
		while (map.OnBtnClose() < 1)
		{
			if(!printed)
			{
				printf("\nAwaiting client connections...\n"));
				printed	= true;
			}
			
		}
		printf("\nNumber of connections is %d \n", map.OnBtnClose());
	}
	
	try
	{
		pAdmCallbacks = new MyAdmCallbacks();
	}
	catch (OmneException& oEx)
	{
		iCode = oEx.getErrorCode();
		cout << "MyAdmCallbacks::MyAdmCallbacks() error : " << iCode << endl;
		return (BAD);
	}

	/*   ----------------------------------------------------------------   */
	/*   The following fake envp contains the settings for connecting to    */
	/*   Rithmic 01 Test.  To connect to a different instance of the        */
	/*   Rithmic trading platform, consult appropriate connection params    */
	/*   document in your download directory.                               */

	fake_envp[0] = "MML_DMN_SRVR_ADDR=rituz00100.00.rithmic.com:65000~rituz00100.00.rithmic.net:65000~rituz00100.00.theomne.net:65000~rituz00100.00.theomne.com:65000";
	fake_envp[1] = "MML_DOMAIN_NAME=rithmic_uat_dmz_domain";
	fake_envp[2] = "MML_LIC_SRVR_ADDR=rituz00100.00.rithmic.com:56000~rituz00100.00.rithmic.net:56000~rituz00100.00.theomne.net:56000~rituz00100.00.theomne.com:56000";
	fake_envp[3] = "MML_LOC_BROK_ADDR=rituz00100.00.rithmic.com:64100";
	fake_envp[4] = "MML_LOGGER_ADDR=rituz00100.00.rithmic.com:45454~rituz00100.00.rithmic.net:45454~rituz00100.00.theomne.com:45454~rituz00100.00.theomne.net:45454";
	fake_envp[5] = "MML_LOG_TYPE=log_net";

	/*   The SSL files are located in the ./<version>/etc directory         */
	/*   of the R | API package.  The settings below assume that those      */
	/*   files are in the current working directory.  Normally you should   */
	/*   specify the full path to these files.                              */
	fake_envp[6] = "MML_SSL_CLNT_AUTH_FILE=C:\\Users\\User\\Documents\\9.9.0.0\\etc\\rithmic_ssl_cert_auth_params";
	fake_envp[7] = "MML_SSL_CLNT_CERT_FILE=C:\\Users\\User\\Documents\\9.9.0.0\\etc\\rithmic_ssl_client_params";
	fake_envp[8] = "MML_SSL_CLNT_KEY_FILE=C:\\Users\\User\\Documents\\9.9.0.0\\etc\\rithmic_ssl_client_private_key";

	fake_envp[9] = "USER=andrew.kowuoche@gmail.com";
	fake_envp[10] = NULL;

	/*   ----------------------------------------------------------------   */
	/*   The following value for REngineParams::sAdmCnnctPt assumes the     */
	/*   app is connecting to the Rithmic 01 Test environment.              */
	/*   REngineParams::sAppName must be changed in order to log into the   */
	/*   Rithmic Paper Trading environment, or any production environment.  */

	oParams.sAppName.pData = "SampleMD";
	oParams.sAppName.iDataLen = (int)strlen(oParams.sAppName.pData);
	oParams.sAppVersion.pData = "1.0.0.0";
	oParams.sAppVersion.iDataLen = (int)strlen(oParams.sAppVersion.pData);
	oParams.sAdmCnnctPt.pData = "dd_admin_sslc";
	oParams.sAdmCnnctPt.iDataLen = (int)strlen(oParams.sAdmCnnctPt.pData);
	oParams.envp = fake_envp;
	oParams.pAdmCallbacks = pAdmCallbacks;
	oParams.sLogFilePath.pData = "smd.log";
	oParams.sLogFilePath.iDataLen = (int)strlen(oParams.sLogFilePath.pData);

	/*   ----------------------------------------------------------------   */

	try
	{
		pEngine = new REngine(&oParams);
	}
	catch (OmneException& oEx)
	{
		delete pAdmCallbacks;

		iCode = oEx.getErrorCode();
		cout << "REngine::REngine() error : " << iCode << endl;
		return (BAD);
	}

	/*   ----------------------------------------------------------------   */
	/*   instantiate a callback object - prerequisite for logging in */

	try
	{
		pCallbacks = new MyCallbacks();
	}
	catch (OmneException& oEx)
	{
		delete pEngine;
		delete pAdmCallbacks;

		iCode = oEx.getErrorCode();
		cout << "MyCallbacks::MyCallbacks() error : " << iCode << endl;
		return (BAD);
	}

	/*   ----------------------------------------------------------------   */
	/*   Set up parameters for logging in.  Again, the MdCnnctPt and        */
	/*   TsCnnctPt have values for Rithmic 01 Test.  Add values for other   */
	/*   members of LoginParams to log into other subsystems of the         */
	/*   infrastructure like like pnl and history.                          */

	oLoginParams.pCallbacks = pCallbacks;

	oLoginParams.sMdUser.pData = argv[1];
	oLoginParams.sMdUser.iDataLen = (int)strlen(oLoginParams.sMdUser.pData);

	oLoginParams.sMdPassword.pData = argv[2];
	oLoginParams.sMdPassword.iDataLen = (int)strlen(oLoginParams.sMdPassword.pData);

	oLoginParams.sMdCnnctPt.pData = "login_agent_tpc";
	oLoginParams.sMdCnnctPt.iDataLen = (int)strlen(oLoginParams.sMdCnnctPt.pData);

	oLoginParams.sUser.pData = argv[1];
	oLoginParams.sUser.iDataLen = (int)strlen(oLoginParams.sUser.pData);

	oLoginParams.sPassword.pData = argv[2];
	oLoginParams.sPassword.iDataLen = (int)strlen(oLoginParams.sPassword.pData);

	oLoginParams.sTsCnnctPt.pData = "login_agent_opc";
	oLoginParams.sTsCnnctPt.iDataLen = (int)strlen(oLoginParams.sTsCnnctPt.pData);

	/*   ----------------------------------------------------------------   */

	if (!pEngine->login(&oLoginParams, &iCode))
	{
		cout << "REngine::login() error : " << iCode << endl;

		delete pEngine;
		delete pCallbacks;
		delete pAdmCallbacks;

		return (BAD);
	}

	/*   ----------------------------------------------------------------   */
	/*   After calling REngine::login, RCallbacks::Alert may be called a    */
	/*   number of times.  Wait for when the login to the MdCnnctPt is      */
	/*   complete.  (See MyCallbacks::Alert() for details).                 */

	while (!g_bMdLoginComplete)
	{
#ifdef WinOS
		sleep(1);
#else
		Sleep(1000);
#endif
	}

	/*   ----------------------------------------------------------------   */

	sExchange.pData = argv[3];
	sExchange.iDataLen = (int)strlen(sExchange.pData);

	/*   ----------------------------------------------------------------   */

	sTicker.pData = argv[4];
	sTicker.iDataLen = (int)strlen(sTicker.pData);

	/*   ----------------------------------------------------------------   */
	/*   Subscription flags are OR'd.  Add more flags to get more data.     */

	iFlags = (MD_PRINTS | MD_BEST);

	/*   ----------------------------------------------------------------   */

	if (!pEngine->subscribe(&sExchange, &sTicker, iFlags, &iCode))
	{
		cout << "REngine::subscribe() error : " << iCode << endl;

		delete pEngine;
		delete pCallbacks;
		delete pAdmCallbacks;

		return (BAD);
	}

	/*   ----------------------------------------------------------------   */

	sExchange.pData = "CME";
	sExchange.iDataLen = (int)strlen(sExchange.pData);

	/*   ----------------------------------------------------------------   */

	sTicker.pData = "NQH8";
	sTicker.iDataLen = (int)strlen(sTicker.pData);

	/*   ----------------------------------------------------------------   */

	/*   Subscription flags are OR'd.  Add more flags to get more data.     */

	iFlags = (MD_PRINTS | MD_BEST);

	/*   ----------------------------------------------------------------   */

	if (!pEngine->subscribe(&sExchange, &sTicker, iFlags, &iCode))
	{
		cout << "REngine::subscribe() error : " << iCode << endl;

		delete pEngine;
		delete pCallbacks;
		delete pAdmCallbacks;

		return (BAD);
	}

	/*   ----------------------------------------------------------------   */

	/*   press 'enter' to quit... */

	fgetc(stdin);

	/*   ----------------------------------------------------------------   */

	delete pEngine;
	delete pCallbacks;
	delete pAdmCallbacks;

	/*   ----------------------------------------------------------------   */

	return (GOOD);
}

// ----------------------------------------------------------------
// -------------------------- HELPER ------------------------------
// ----------------------------------------------------------------

// Appends formatted text to the string ms_Output which is later written to the Output Editbox in the GUI thread
void CSocketDemoDlg::Print(CString s_Format, ...)
{
	va_list  args;
	va_start(args, s_Format);

	int BUFLEN = 50000;

	CString s_Out;
	TCHAR*  t_Out = s_Out.GetBuffer(BUFLEN + 1);

	_vsntprintf(t_Out, BUFLEN, s_Format, args);

	// If the new line should be longer than BUFLEN it is cropped.
	t_Out[BUFLEN] = 0;
	s_Out.ReleaseBuffer();

	if (s_Out.GetLength() == BUFLEN)
		s_Out += _T("...<cut>");

	// The edit box does not display a single "\n" correctly. It requires always "\r\n"
	s_Out.Replace(_T("\r"), _T(""));
	s_Out.Replace(_T("\n"), _T("\r\n"));
	s_Out += _T("\r\n");

	// The variable ms_Output is manipulated from two threads
	// The critical section assures thread safety
	EnterCriticalSection(&mk_Critical);
	ms_Output += s_Out;
	LeaveCriticalSection(&mk_Critical);
}

// Copies the not zero terminated data in s8_Buf into a CString
// u32_Bytes always specifies the length in bytes no matter if compiled as Unicode or MBCS
CString CSocketDemoDlg::CopyToString(char* s8_Buf, DWORD u32_Bytes)
{
	DWORD u32_StrLen = u32_Bytes / sizeof(TCHAR);

	CString s_String;
	char*  s8_String = (char*)s_String.GetBuffer(u32_StrLen + 1);
	memcpy(s8_String, s8_Buf, u32_Bytes);
	s_String.ReleaseBuffer(u32_StrLen);

	return s_String;
}

// Format the display string for the given socket
// returns "Server (192.168.1.100)" or "Client 71C (192.168.1.100)"
CString CSocketDemoDlg::FormatDisplayName(SOCKET h_Socket)
{
	CString s_IP = FormatIP(mi_SocketList.GetValueByKey(h_Socket));
	CString s_Disp;
	if (mi_Socket.GetState() & TCP::cSocket::E_Server)
		s_Disp.Format(_T("Client %X (%s)"), h_Socket, s_IP);
	else
		s_Disp.Format(_T("Server (%s)"), s_IP);

	return s_Disp;
}

// Formats an IP address "192.168.1.100"
CString CSocketDemoDlg::FormatIP(DWORD u32_IP)
{
	BYTE* pu8_Addr = (BYTE*)&u32_IP;

	CString s_IP;
	s_IP.Format(_T("%d.%d.%d.%d"), pu8_Addr[0], pu8_Addr[1], pu8_Addr[2], pu8_Addr[3]);
	return s_IP;
}

// Get a human readable error message for an API error code
CString CSocketDemoDlg::GetErrMsg(DWORD u32_Error)
{
	// Some translations of error codes are really stupid --> show the original error code.
	CString s_Code;
	switch (u32_Error)
	{
	case WSAEINTR:                s_Code = _T("WSAEINTR"); break;
	case WSAEBADF:                s_Code = _T("WSAEBADF"); break;
	case WSAEACCES:               s_Code = _T("WSAEACCES"); break;
	case WSAEFAULT:               s_Code = _T("WSAEFAULT"); break;
	case WSAEINVAL:               s_Code = _T("WSAEINVAL"); break;
	case WSAEMFILE:               s_Code = _T("WSAEMFILE"); break;
	case WSAEWOULDBLOCK:          s_Code = _T("WSAEWOULDBLOCK"); break;
	case WSAEINPROGRESS:          s_Code = _T("WSAEINPROGRESS"); break;
	case WSAEALREADY:             s_Code = _T("WSAEALREADY"); break;
	case WSAENOTSOCK:             s_Code = _T("WSAENOTSOCK"); break;
	case WSAEDESTADDRREQ:         s_Code = _T("WSAEDESTADDRREQ"); break;
	case WSAEMSGSIZE:             s_Code = _T("WSAEMSGSIZE"); break;
	case WSAEPROTOTYPE:           s_Code = _T("WSAEPROTOTYPE"); break;
	case WSAENOPROTOOPT:          s_Code = _T("WSAENOPROTOOPT"); break;
	case WSAEPROTONOSUPPORT:      s_Code = _T("WSAEPROTONOSUPPORT"); break;
	case WSAESOCKTNOSUPPORT:      s_Code = _T("WSAESOCKTNOSUPPORT"); break;
	case WSAEOPNOTSUPP:           s_Code = _T("WSAEOPNOTSUPP"); break;
	case WSAEPFNOSUPPORT:         s_Code = _T("WSAEPFNOSUPPORT"); break;
	case WSAEAFNOSUPPORT:         s_Code = _T("WSAEAFNOSUPPORT"); break;
	case WSAEADDRINUSE:           s_Code = _T("WSAEADDRINUSE"); break;
	case WSAEADDRNOTAVAIL:        s_Code = _T("WSAEADDRNOTAVAIL"); break;
	case WSAENETDOWN:             s_Code = _T("WSAENETDOWN"); break;
	case WSAENETUNREACH:          s_Code = _T("WSAENETUNREACH"); break;
	case WSAENETRESET:            s_Code = _T("WSAENETRESET"); break;
	case WSAECONNABORTED:         s_Code = _T("WSAECONNABORTED"); break;
	case WSAECONNRESET:           s_Code = _T("WSAECONNRESET"); break;
	case WSAENOBUFS:              s_Code = _T("WSAENOBUFS"); break;
	case WSAEISCONN:              s_Code = _T("WSAEISCONN"); break;
	case WSAENOTCONN:             s_Code = _T("WSAENOTCONN"); break;
	case WSAESHUTDOWN:            s_Code = _T("WSAESHUTDOWN"); break;
	case WSAETOOMANYREFS:         s_Code = _T("WSAETOOMANYREFS"); break;
	case WSAETIMEDOUT:            s_Code = _T("WSAETIMEDOUT"); break;
	case WSAECONNREFUSED:         s_Code = _T("WSAECONNREFUSED"); break;
	case WSAELOOP:                s_Code = _T("WSAELOOP"); break;
	case WSAENAMETOOLONG:         s_Code = _T("WSAENAMETOOLONG"); break;
	case WSAEHOSTDOWN:            s_Code = _T("WSAEHOSTDOWN"); break;
	case WSAEHOSTUNREACH:         s_Code = _T("WSAEHOSTUNREACH"); break;
	case WSAENOTEMPTY:            s_Code = _T("WSAENOTEMPTY"); break;
	case WSAEPROCLIM:             s_Code = _T("WSAEPROCLIM"); break;
	case WSAEUSERS:               s_Code = _T("WSAEUSERS"); break;
	case WSAEDQUOT:               s_Code = _T("WSAEDQUOT"); break;
	case WSAESTALE:               s_Code = _T("WSAESTALE"); break;
	case WSAEREMOTE:              s_Code = _T("WSAEREMOTE"); break;
	case WSASYSNOTREADY:          s_Code = _T("WSASYSNOTREADY"); break;
	case WSAVERNOTSUPPORTED:      s_Code = _T("WSAVERNOTSUPPORTED"); break;
	case WSANOTINITIALISED:       s_Code = _T("WSANOTINITIALISED"); break;
	case WSAEDISCON:              s_Code = _T("WSAEDISCON"); break;
	case WSAENOMORE:              s_Code = _T("WSAENOMORE"); break;
	case WSAECANCELLED:           s_Code = _T("WSAECANCELLED"); break;
	case WSAEINVALIDPROCTABLE:    s_Code = _T("WSAEINVALIDPROCTABLE"); break;
	case WSAEINVALIDPROVIDER:     s_Code = _T("WSAEINVALIDPROVIDER"); break;
	case WSAEPROVIDERFAILEDINIT:  s_Code = _T("WSAEPROVIDERFAILEDINIT"); break;
	case WSASYSCALLFAILURE:       s_Code = _T("WSASYSCALLFAILURE"); break;
	case WSASERVICE_NOT_FOUND:    s_Code = _T("WSASERVICE_NOT_FOUND"); break;
	case WSATYPE_NOT_FOUND:       s_Code = _T("WSATYPE_NOT_FOUND"); break;
	case WSA_E_NO_MORE:           s_Code = _T("WSA_E_NO_MORE"); break;
	case WSA_E_CANCELLED:         s_Code = _T("WSA_E_CANCELLED"); break;
	case WSAEREFUSED:             s_Code = _T("WSAEREFUSED"); break;
	case WSAHOST_NOT_FOUND:       s_Code = _T("WSAHOST_NOT_FOUND"); break;
	case WSATRY_AGAIN:            s_Code = _T("WSATRY_AGAIN"); break;
	case WSANO_RECOVERY:          s_Code = _T("WSANO_RECOVERY"); break;
	case WSANO_DATA:              s_Code = _T("WSANO_DATA"); break;
	case WSA_IO_PENDING:          s_Code = _T("WSA_IO_PENDING"); break;
	case WSA_IO_INCOMPLETE:       s_Code = _T("WSA_IO_INCOMPLETE"); break;
	case WSA_INVALID_HANDLE:      s_Code = _T("WSA_INVALID_HANDLE"); break;
	case WSA_INVALID_PARAMETER:   s_Code = _T("WSA_INVALID_PARAMETER"); break;
	case WSA_NOT_ENOUGH_MEMORY:   s_Code = _T("WSA_NOT_ENOUGH_MEMORY"); break;
	case WSA_OPERATION_ABORTED:   s_Code = _T("WSA_OPERATION_ABORTED"); break;

	default:
		s_Code.Format(_T("Code %u"), u32_Error);
		break;
	}

	CString s_Out;
	const DWORD BUFLEN = 1000;
	TCHAR t_Buf[BUFLEN];

	if (FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, 0, u32_Error, 0, t_Buf, BUFLEN, 0))
		s_Out.Format(_T("%s: %s"), s_Code, t_Buf);
	else
		s_Out.Format(_T("%s: Windows has no explanation for this error"), s_Code);

	s_Out.TrimRight(); // some messages end with useless Linefeeds
	return s_Out;
}

/*   =====================================================================   */
